import { MdEditor, MdPreview, MdCatalog} from 'md-editor-rt';

import 'md-editor-rt/lib/style.css';
import 'md-editor-rt/lib/preview.css';

import { useState } from 'react';

import Head from "next/head";
import Link from "next/link";
import { userInfo } from 'os';


const Conditional = ({
    showWhen,
    children,
    text
    }: {
    showWhen: boolean;
    children: React.ReactNode;
    text: string
    }) => { 
    if(showWhen) {
      return <>{children}</>;
    }
    return <>
    <MdPreview modelValue={text} />
      </>;
  };

export default () => {
  const [text, setText] = useState(`# Graph Traversals

## Depth first
Depth-first search (DFS) is a graph traversal algorithm that visits all the vertices of a graph in depth-first order, typically using a stack data structure. It is commonly used for tasks such as traversing all nodes reachable from a given starting node, or for finding a path between two nodes in a graph. It can also be used to find strongly connected components of a graph

**Characteristics:**		NVT
**Time Complexity:** 		O(E + V) where E is the number of edges and V is the number of 
  vertices in the graph.
  **Data Structures used:**		Stack, Graph
  
  **Code:**`);

  const [isEdit, setIsEdit] = useState(true);

  const generate = () => {
    

    setText(text + `\n# Generated by ANDY\n\`\`\`java
    public List<Integer> traverseDepthFirst(Vertex startPoint) {
        Stack<Vertex> stack = new Stack<>();
        Set<Vertex> visited = new HashSet<>();
        List<Vertex> result = new LinkedList<>();
        stack.push(startPoint);
        while(!stack.isEmpty()){
            Vertex currentVertex = stack.pop();
            if(currentVertex.getNeighbours() == null){
                currentVertex = stack.pop();
            }else{
                for(Vertex neighbourVertex : currentVertex.getNeighbours()){
                    if(!visited.contains(neighbourVertex)){
                        visited.add(neighbourVertex);
                        result.add(neighbourVertex);
                        stack.push(neighbourVertex);
                    }
                }
                currentVertex = stack.pop();
            }
        }
        return visited;
    }
    \`\`\``);
  }

  
  return (
    <>
      <Head>
        <title>YourStudyBuddy</title>
        <meta name="description" content="YourStudyBuddy" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="flex min-h-screen flex-col items-center justify-start bg-[#ffff]">
      <nav className="flex items-center justify-end w-screen h-10 bg-black">
            <div className="lg:gap-16 gap-4 md:px-8">
              {/* Create a link to bring to the education section which is on the same page*/}
              <Link href="/#education" className="lg:text-lg  text-xs font-bold text-white hover:text-[#283044]">
                Profile
              </Link>
            </div>
          </nav>
        <div className="container flex flex-col items-center justify-center gap-12 px-4 py-16 ">


          <h1 className="text-5xl font-extrabold tracking-tight text-black sm:text-[5rem]">
            Learn with <span className="text-[#808080]">Andy</span>!
          </h1>
          <h2 className="text-2xl font-bold text-black">
            Your Study Buddy! 😁
          </h2>
          {/* Below we create an md editor on save we replace this with the rendered preview object
          if a user presses the edit button they can edit again */}
         <div className = "h-[40%] w-[85%]">
          <Conditional showWhen={isEdit} text={text}>
                <MdEditor modelValue={text} onChange={setText} theme="dark" language='en-US' showToolbarName
                      onSave={(v, h) => {
                        setIsEdit(false);
                        console.log(v);
                        // create a new editor instance that is only the rendered markdow
                  }}/>
            </Conditional>
        </div>

        {/* Create a button that changes the state to editor true */}
        {/* Create a dive with two buttosn one to edit one to confirm */}
        <div className="flex flex-row gap-4">

        <button className=" bg-[#808080]/20 p-4 text-black hover:bg-[#808080]/40 rounded-lg">Confirm</button>

        <button className=" bg-[#808080]/20 p-4 text-black hover:bg-[#808080]/40 rounded-lg" onClick={() => setIsEdit(true) }>Edit</button>

        <button className=" bg-[#808080]/20 p-4 text-black hover:bg-[#808080]/40 rounded-lg" onClick={() => generate() }>Andy 🪄</button>
        
        </div>

        {/* A text field that    */}
        
        </div>
      </main>
    </>
  );

};